# 整体二分

如果要多次二分求解问题, 但是多次二分复杂度暴了, 可以考虑整体二分.

先考虑一个简单题: 不排序多次查询全局第 k 小.

可以前缀和优化 $O(q\log V)$ 的总复杂度对每个询问单独二分. 但是如果把所有询问综合考虑, 模仿单询问进行二分, 即有一个询问序列, 当前枚举的中点是 $mid$, 那么可以根据检查结果将询问序列二分为两部分, 满足和不满足的. 那么进而让两个询问序列递归到 $[l,mid]$ 和 $[mid+1,r]$ 进行计算. 当 $l=r$ 时即得出当前询问序列答案.

如果能够用 $O(T)$ 处理每层询问序列的划分, 那么总复杂度会是 $O(TlogV)$. 其中 $logV$ 是总共递归层数. 在此题中, 是 $T=V+m$. 因为就算使用最暴力的遍历, 每层 check 需要 $O(V)$ , 如果同用前缀和优化则有均摊下总的 $O(V)$ 的总复杂度; 每层划分序列需要 $O(m)$. 在这一题中并未表现出显著优势.

以上是因为单独二分的 check 的复杂度可以被优化到 $O(1)$. 但是假设 no heavy ds 的前提下 (不开主席树) 多次查询区间第 k 小. 独立二分每次 check 会被搞到 $O(n)$. 总共是 $O(nqlogn)$, 不可接受.

但是按照整体二分的思路, 可以修改 check 函数达成更优秀的复杂度. 即是当前的值域是 $[l,r]$, 除了询问额外存储所有的值域点, 每层点数 $O(n)$ 可以接受. 用树状数组维护当前区间的判定贡献序列中所有值域点 (就是按照值域二分把值域点序列分为两半, 前一半用于检查 mid) 在下标数组中出现的位置, 可以对所有询问序列实现 O(logV) 的检查. 同时每层均摊是 $O(NlogV)$ 的树状数组增删. 于是每层复杂度降低到了 $T=qlogV+NLogV$, 来到了 $O((q+N)log^2V)$.

链接: [P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)

整体二分中, 一般会记录询问序列和贡献序列, 后者在上题中表现为 $(val,idx)$ 的二元组. 如果能在良好复杂度内实现序列划分 (即在二分判定的贡献序列内, 判定所有询问的归属) 就能实现良好的复杂度. 这个过程比较有技巧性. 此外, 整体二分需要满足一些前提性质:

1. 询问离线 (一般整体二分复杂度劣于数据结构, 所以对于 ds 题不考虑)
2. 二分判定过程中, 贡献是满足: 交换律, 结合率, 线性相加的.
3. 如果有修改, 修改必须彼此不影响, 修改必须独立于判定.

## 练习
[CF1997E Level Up](https://www.luogu.com.cn/problem/CF1997E)
不难发现单调性: k 越小, 一个位置越可能跑. 于是可以对每个位置考虑二分: 不会逃跑的最低 k 是多少. 直接模拟 check 的复杂度只能是 $O(idx)$. 也就是 $O(n^2logn)$ 不可行.

考虑整体二分. 假设当前是区间 $[l,r]$. 发现直接模拟递推 check 每层依旧是 $O(n*time)$, 而 $\sum time = n$. 所以很差, 只是优化了一个 $log$. 

但是这里有一个好性质, 当检查 mid, 那些在左侧答案区间的询问点必定不会逃跑, 在右侧答案区间的询问点必定会逃跑. 而注意二分的这个过程在检查前可以加上所有左侧答案区间的某些修改.
 并且对于每个询问可以这样转化: 在此下标之前没有逃跑的怪兽数量是否满足 $sum>=level*k$.

 于是可以按照下标顺序处理问题. 首先记录了左侧答案区间没有逃跑的所有点, 其次按照下标顺序, 检查所有询问即可. 注意要在结束时加上区间内的询问贡献.
